#!/usr/bin/env python3
import argparse
import os
import re

from requests import get


def in_root(dir: str) -> bool:
    '''
    Determines whether the dir is the root or not.
    The READMEs this lists should never show the readme in the current folder. 
    '''
    return not re.search("/.*/", dir)  # if it has two /, its not in root dir (root refers to /codeforces)


def problem_solved(dir: str) -> bool:
    '''
    Determines whether a problem is solved or not.
    
    A problem is solved if it contains the string "Solved!".
    '''
    with open(dir+"/README.md", "r") as f:
        read_file = f.read()
    return re.search("Solved!", read_file)


def sort_by_difficulty(dirs: list, tags=[]) -> list:
    '''
    Sorts a list of dirs by the difficulty of the problems it contains.
    '''
    weights = []  # stores the numerical difficulties of each problem.

    for dir in dirs:
        difficulty_string = dir[2:6]  # the difficulty is always 4 characters long, so we can just do this.
        if difficulty_string == "easy":
            weights.append(1000) 
        else:
            weights.append(int(difficulty_string))

    if tags:
        sorted_zip = sorted(zip(weights, dirs))  # zip the weights and the dirs, then sort based on the weights
        sorted_tags = sorted(zip(weights, tags))  # zip the weights and the tags, then sort based on the weights
        return [x[1] for x in sorted_zip], [x[1] for x in sorted_tags]  # we don't want to have the weights as well, so just return the dirs.
    else:
        sorted_zip = sorted(zip(weights, dirs))  # zip the weights and the dirs, then sort based on the weights
        return [x[1] for x in sorted_zip]  # we don't want to have the weights as well, so just return the dirs.


def in_tag_list(dir: str, tags: list[str]) -> bool:
    '''
    See if the tags that you want to search by are in this problem.  
    '''
    name_conversions = {
        "bsearch": "binary search",
        "btree": "binary trees",
        "dp": "dynamic programming",
    }
    if not tags:
        return True

    tag_line = get_tags_in_file(dir+"/README.md")   
    tag_line = [tag.lower() for tag in tag_line]
    for tag in tags:
        tag = tag.replace("_", " ")
        if tag in name_conversions.keys():
            if name_conversions[tag] in tag_line:
                continue

        if not tag in tag_line:
            return False
    return True


def get_tags_in_file(file: str) -> list[str]:
    '''
    Gets a list of tags in a given file. 
    '''
    tag_line = ""
    with open(file, "r") as f:
        for line in f.readlines():
            if line[:9] == "**Tags**:":
                tag_line = line[9:]
                break

    tag_line = [tag.strip() for tag in tag_line.split(", ")]
    return tag_line


def setup_argparse() -> argparse.ArgumentParser:
    '''
    Setup argparse arguments.
    '''
    parser = argparse.ArgumentParser(description='List codeforces challenges')
    parser.add_argument('-t, --todo', 
                        dest="unsolved", 
                        action="store_true", 
                        help="List incomplete challenges")
    parser.add_argument('-c, --completed', 
                        dest="solved", 
                        action="store_true", 
                        help="List completed challenges")
    parser.add_argument('--show-tags',
                        dest="show_tags",
                        action="store_true",
                        help="Whether to show the tags for each problem or not")
    parser.add_argument('--tags',
                        dest="tags",
                        nargs="*",
                        help="Show only problems containing the specified tags")
    return parser.parse_args()


if __name__ == "__main__":
    '''
    Look in all subdirectories and get the path to every dir.
    Then look in all of those directories for README.md and see if it contains the string "Solved!"
    If it does, add it to the list of solved problems.
    Otherwise, add it to the list of unsolved problems.
    Print both of these lists.
    '''
    parser = setup_argparse()

    # this is to ensure that, if they don't specify the optional flags
    # then both solved and unsolved problems are shown. 
    show_solved = parser.solved or not parser.unsolved
    show_unsolved = parser.unsolved or not parser.solved
    tags = parser.tags
    show_tags = parser.show_tags

    # Get a list of all subdirectories (and the subdirectories inside those subdirectories etc)
    dirs = [root
             for root, dirs, files in os.walk("./")  # look in subfolders
             for name in files
             if name == "README.md"]  # if the folder contains a README.md, we want it.

    # Seperate the list of dirs into solved and unsolved
    solved = []
    unsolved = []
    solved_tags = []
    unsolved_tags = []
    for dir in dirs:
        if not in_root(dir):  # ignore readmes in the main folder
            if in_tag_list(dir, tags):
                file_tags = get_tags_in_file(dir+"/README.md")
                if problem_solved(dir):
                    solved.append(dir)
                    solved_tags.append(file_tags)
                else:
                    unsolved.append(dir)
                    unsolved_tags.append(file_tags)

    # Show the solved problems if appropriate
    if show_solved:
        solved, solved_tags = sort_by_difficulty(solved, solved_tags)
        print(f"{len(solved)} Solved Problems:")
        if show_tags:
            [print(f"{file}: {tags}") for file, tags in zip(solved, solved_tags)]
        else:
            [print(file) for file, tags in zip(solved, solved_tags)]

    # Show unsolved problems if appropriate
    if show_unsolved:
        if show_solved:
            print("")  # newline for formatting

        unsolved, unsolved_tags = sort_by_difficulty(unsolved, unsolved_tags)
        print(f"{len(unsolved)} Unsolved Problems:")
        if show_tags:
            [print(f"{file}: {tags}") for file, tags in zip(unsolved, unsolved_tags)]
        else:
            [print(file) for file, tags in zip(unsolved, unsolved_tags)]
